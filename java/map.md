1. HashMap是数组，数组元素是链表  
1.1 数组初始化为16个元素，resize的阈值为75%  
1.2 `(n - 1) & hash`求数组下标，n为数组长度，如果地位相同，高位不同，会有很多冲突，如：101，201, 301  
1.3 hashCode右移16位再和hashCode异或：  
`h = key.hashCode()) ^ (h >>> 16)`  高位取反，高低位异或  
    > 1111000011110000 1111111111111100  
      0000000000000000 1111000011110000   ==>  
      0000111100001111 0000111100001100  
    >
      ```
      log.info("{}", 1234501 & 16);
      log.info("{}", 2234501 & 16);
      log.info("{}", 3234501 & 16);
      log.info("{}", (1234501 ^ (1234501 >>> 16)) & 16);
      log.info("{}", (2234501 ^ (2234501 >>> 16)) & 16);
      log.info("{}", (3234501 ^ (3234501 >>> 16)) & 16);`  
      ```

2. collide  
2.1 如果算出的下标位置的数组元素已经存在，则：  
2.1.1 如hashCode相同，key也相同，则直接覆盖旧值  
2.1.2 如冲突元素为TreeNode, 说明冲突元素大于TREEIFY_THRESHOLD，放入tree中  
2.1.3 还是列表，则循环到最后一个。此时判断1是否要转为tree存储，2如果key相同则直接替换

3. resize  
3.1 容量到达阈值后会resize：new 一个新数组，然后把旧数组的内容填进新数组

